<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCTS Algorithm Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
        .canvas-container {
            width: 100%;
            height: 700px;
            overflow: auto;
            position: relative;
        }
        .canvas-container canvas {
            display: block;
            width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Game Logic
        class SimplePairGame {
          constructor(board = null, currentPlayer = 1) {
            this.board = board === null ? [0, 0, 0, 0] : [...board];
            this.currentPlayer = currentPlayer;
            this.winningPairs = [[0, 1], [1, 2], [2, 3]];
          }

          getAvailableMoves() {
            return this.board.map((x, i) => x === 0 ? i : null).filter(x => x !== null);
          }

          makeMove(move) {
            const newBoard = [...this.board];
            newBoard[move] = this.currentPlayer;
            const nextPlayer = this.currentPlayer === 2 ? 1 : 2;
            return new SimplePairGame(newBoard, nextPlayer);
          }

          isTerminal() {
            for (const [p1, p2] of this.winningPairs) {
              if (this.board[p1] === this.board[p2] && this.board[p2] !== 0) return true;
            }
            return this.getAvailableMoves().length === 0;
          }

          getWinner() {
            for (const [p1, p2] of this.winningPairs) {
              if (this.board[p1] === this.board[p2] && this.board[p2] !== 0) {
                return this.board[p1];
              }
            }
            return null;
          }

          clone() {
            return new SimplePairGame(this.board, this.currentPlayer);
          }
        }

        // MCTS Node
        class MCTSNode {
          constructor(state, parent = null, action = null, rootPlayer = null) {
            this.state = state;
            this.parent = parent;
            this.action = action;
            this.children = [];
            this.visits = 0;
            this.wins = 0;
            this.unvisitedMoves = state.getAvailableMoves();
            this.id = Math.random().toString(36).substr(2, 9);

            // Store the perspective player (the player we're optimizing for)
            if (rootPlayer !== null) {
              this.rootPlayer = rootPlayer;
            } else if (parent !== null) {
              this.rootPlayer = parent.rootPlayer;
            } else {
              this.rootPlayer = state.currentPlayer;
            }

            // Root node special handling
            this.isRoot = parent === null;
          }

          expand() {
            const move = this.unvisitedMoves.pop();
            const nextState = this.state.makeMove(move);
            const child = new MCTSNode(nextState, this, move, this.rootPlayer);
            this.children.push(child);
            return child;
          }

          rollout(useHeuristic = false) {
            if (useHeuristic) {
              return this.heuristicRollout();
            }

            let current = this.state.clone();
            const moves = [];
            while (!current.isTerminal()) {
              const available = current.getAvailableMoves();
              const move = available[Math.floor(Math.random() * available.length)];
              moves.push({ player: current.currentPlayer, move });
              current = current.makeMove(move);
            }
            const winner = current.getWinner();
            const result = winner === this.rootPlayer ? 1.0 : (winner === null ? 0.5 : 0.0);
            return { result, moves, finalBoard: current.board, winner };
          }

          heuristicRollout() {
            const findWinningMove = (state) => {
              const player = state.currentPlayer;
              for (const move of state.getAvailableMoves()) {
                for (const pair of state.winningPairs) {
                  if (pair.includes(move)) {
                    const otherPos = pair[0] === move ? pair[1] : pair[0];
                    if (state.board[otherPos] === player) {
                      return move;
                    }
                  }
                }
              }
              return null;
            };

            const findBlockingMove = (state) => {
              const opponent = 3 - state.currentPlayer;
              for (const move of state.getAvailableMoves()) {
                for (const pair of state.winningPairs) {
                  if (pair.includes(move)) {
                    const otherPos = pair[0] === move ? pair[1] : pair[0];
                    if (state.board[otherPos] === opponent) {
                      return move;
                    }
                  }
                }
              }
              return null;
            };

            const findDoubleThreatMove = (state) => {
              const player = state.currentPlayer;
              for (const move of state.getAvailableMoves()) {
                const newBoard = [...state.board];
                newBoard[move] = player;
                let threats = 0;
                for (const pair of state.winningPairs) {
                  if (pair.includes(move)) {
                    const otherPos = pair[0] === move ? pair[1] : pair[0];
                    if (newBoard[otherPos] === 0) {
                      threats += 1;
                    }
                  }
                }
                if (threats >= 2) {
                  return move;
                }
              }
              return null;
            };

            let current = this.state.clone();
            const moves = [];

            while (!current.isTerminal()) {
              const player = current.currentPlayer;
              let move = null;

              move = findWinningMove(current);
              if (move !== null) {
                moves.push({ player, move });
                current = current.makeMove(move);
                continue;
              }

              move = findBlockingMove(current);
              if (move !== null) {
                moves.push({ player, move });
                current = current.makeMove(move);
                continue;
              }

              move = findDoubleThreatMove(current);
              if (move !== null) {
                moves.push({ player, move });
                current = current.makeMove(move);
                continue;
              }

              const available = current.getAvailableMoves();
              move = available[Math.floor(Math.random() * available.length)];
              moves.push({ player, move });
              current = current.makeMove(move);
            }

            const winner = current.getWinner();
            const result = winner === this.rootPlayer ? 1.0 : (winner === null ? 0.5 : 0.0);
            return { result, moves, finalBoard: current.board, winner };
          }

          backpropagate(result) {
            this.visits += 1;
            if (!this.isRoot) {
              this.wins += result;
            }
            if (this.parent) {
              this.parent.backpropagate(1.0 - result);
            }
          }

          isFullyExpanded() {
            return this.unvisitedMoves.length === 0;
          }

          bestChild(cParam = 1.4) {
            const weights = this.children.map(child => {
              if (child.visits === 0) {
                return Infinity;
              }
              const exploit = child.wins / child.visits;
              const explore = cParam * Math.sqrt((2 * Math.log(this.visits)) / child.visits);
              return exploit + explore;
            });
            const maxWeight = Math.max(...weights);
            return this.children[weights.indexOf(maxWeight)];
          }

          getWinRate() {
            if (this.isRoot) return 0;
            return this.visits > 0 ? (this.wins / this.visits) * 100 : 0;
          }
        }

        // Icons
        const Play = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const SkipForward = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>;
        const RotateCcw = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>;

        // Main Component
      const MCTSVisualizer = () => {
        const [forceRedraw, setForceRedraw] = useState(0);
          const [gameState, setGameState] = useState(new SimplePairGame());
          const [mctsRoot, setMctsRoot] = useState(null);
          const [iterations, setIterations] = useState(30);
          const [currentIteration, setCurrentIteration] = useState(0);
          const [isPlaying, setIsPlaying] = useState(false);
          const [speed, setSpeed] = useState(500);
          const [logs, setLogs] = useState([]);
          const [selectedNode, setSelectedNode] = useState(null);
          const [highlightedPath, setHighlightedPath] = useState([]);
          const [phase, setPhase] = useState('idle');
          const [simulationNodes, setSimulationNodes] = useState([]);
          const [showSimulation, setShowSimulation] = useState(false);
          const [simulationStartBoard, setSimulationStartBoard] = useState(null);
          const [simulationResult, setSimulationResult] = useState(null);
          const [simulationStep, setSimulationStep] = useState(0);
          const [backpropPath, setBackpropPath] = useState([]);
          const [stepByStepMode, setStepByStepMode] = useState(false);
          const [useHeuristic, setUseHeuristic] = useState(false);
          const [player2Engine, setPlayer2Engine] = useState('random'); // 'random' or 'mcts'
          const [waitingForNext, setWaitingForNext] = useState(false);
          const [simulationWinner, setSimulationWinner] = useState(null);
          const [selectionPath, setSelectionPath] = useState([]);
          const [showSelection, setShowSelection] = useState(false);
          const [selectionStep, setSelectionStep] = useState(0);
          const [backpropSteps, setBackpropSteps] = useState([]);
          const [showBackprop, setShowBackprop] = useState(false);
          const [backpropStep, setBackpropStep] = useState(0);
          const [currentPhase, setCurrentPhase] = useState('idle'); // 'selection', 'simulation', 'backprop'
          const canvasRef = useRef(null);
          const animationRef = useRef(null);

          const addLog = (message, type = 'info') => {
            setLogs(prev => [...prev, { message, type, time: Date.now() }].slice(-50));
          };

          const runMCTSIteration = (root) => {
            let node = root;
            const path = [node.id];

            while (!node.state.isTerminal() && node.isFullyExpanded()) {
              node = node.bestChild();
              path.push(node.id);
            }

            if (!node.state.isTerminal() && !node.isFullyExpanded()) {
              node = node.expand();
              path.push(node.id);
            }

            const { result, moves, finalBoard, winner } = node.rollout(useHeuristic);
            node.backpropagate(result);

            return { path, result, node, moves, finalBoard, winner };
          };

          const startMCTS = () => {
            const root = new MCTSNode(gameState);
            setMctsRoot(root);
            setCurrentIteration(0);
            setLogs([]);
            setPhase('running');
            addLog(`Starting MCTS for Player ${gameState.currentPlayer}`, 'success');
          };

        const stepMCTS = () => {
          if (!mctsRoot || currentIteration >= iterations || waitingForNext) return;

          setShowSimulation(false);
          setShowSelection(false);
          setShowBackprop(false);
          setBackpropPath([]);
          setSimulationStep(0);
          setSelectionStep(0);
          setBackpropStep(0);
          setSimulationResult(null);
          setSimulationWinner(null);
          setSelectionPath([]);
          setBackpropSteps([]);

          // Phase 1: Selection & Expansion
          let node = mctsRoot;
          const selPath = [{ node: mctsRoot, ucb: 0, action: null }];

          // Selection
          while (!node.state.isTerminal() && node.isFullyExpanded()) {
            const bestChild = node.bestChild();
            const ucb = (bestChild.wins / bestChild.visits) + 1.4 * Math.sqrt((2 * Math.log(node.visits)) / bestChild.visits);
            selPath.push({ node: bestChild, ucb, action: bestChild.action });
            node = bestChild;
          }

          // Mark for expansion but don't actually expand yet
          let needsExpansion = false;
          if (!node.state.isTerminal() && !node.isFullyExpanded()) {
            needsExpansion = true;
            selPath.push({ node: null, ucb: 0, action: 'pending', expanded: true, needsExpansion: true });
          }

          setSelectionPath(selPath);
          setSelectedNode(node);
          setShowSelection(true);
          setCurrentPhase('selection');

          addLog(`Iteration ${currentIteration + 1}: Starting Selection`, 'info');

          if (stepByStepMode) {
            setSelectionStep(1); // Show root immediately
            setWaitingForNext(true);
          } else {
            // Auto-animate selection
            animateSelection(selPath, node);
          }
        };

          const animateSelection = (selPath, node) => {
            setSelectionStep(1);
            let step = 1;
            const interval = setInterval(() => {
              step++;
              setSelectionStep(step);

              setForceRedraw(prev => prev + 1);

              if (step >= selPath.length) {
                clearInterval(interval);
                setTimeout(() => startSimulation(node), 800);
              }
            }, 600);
          };


          const nextSelectionStep = () => {
            if (currentPhase !== 'selection' || !waitingForNext) return;
            const nextStep = selectionStep + 1;
            setSelectionStep(nextStep);

            if (nextStep >= selectionPath.length) {
              addLog('Selection complete - click Finish Selection to continue', 'info');
              // Don't auto-advance - wait for user to click Finish Selection
            }
          };

          const finishSelection = () => {
            if (currentPhase !== 'selection' || !waitingForNext) return;
            setSelectionStep(selectionPath.length);

            // Actually expand the node now
            let finalNode = selectedNode;
            if (!finalNode.state.isTerminal() && !finalNode.isFullyExpanded()) {
              finalNode = finalNode.expand();
              setSelectedNode(finalNode);
            }

            setTimeout(() => startSimulation(finalNode), 500);
          };


const startSimulation = (node) => {
  setShowSelection(false);
  setCurrentPhase('simulation');

  const { result, moves, finalBoard, winner } = node.rollout(useHeuristic);

  setSimulationNodes(moves);
  setSimulationStartBoard(node.state.board);
  setSimulationWinner(winner);
  setShowSimulation(true);

  addLog('Starting simulation', 'info');

  if (stepByStepMode) {
    setWaitingForNext(true);
  } else {
    animateSimulation(moves, result, node, winner);
  }
};
          const animateSimulation = (moves, result, node, winner) => {
            setCurrentPhase('simulation');
            let step = 0;
            const interval = setInterval(() => {
              step++;
              setSimulationStep(step);

              setForceRedraw(prev => prev + 1);

              if (step >= moves.length) {
                clearInterval(interval);
                setSimulationResult({ result, winner });

                setTimeout(() => {
                  startBackpropagation(result, node);
                }, 1500);
              }
            }, 400);
          };

          const startBackpropagation = (result, node) => {
            setShowSimulation(false);
            setCurrentPhase('backprop');

            // Build backpropagation steps
            const steps = [];
            let current = node;
            let currentResult = result;

           while (current) {
             const oldVisits = current.visits;
             const oldWins = current.wins;

             // Determine who "owns" this node (who played to create it)
             const nodeOwner = current.parent ? (3 - current.state.currentPlayer) : current.rootPlayer;

             // If this node's owner is rootPlayer, use currentResult; otherwise flip it
             const nodeResult = (nodeOwner === current.rootPlayer) ? currentResult : (1.0 - currentResult);

             steps.push({
               node: current,
               action: current.action,
               board: current.state.board,
               player: current.state.currentPlayer,
               isRoot: current.isRoot,
               oldVisits,
               newVisits: oldVisits + 1,
               oldWins,
               newWins: current.isRoot ? oldWins : oldWins + nodeResult,
               result: nodeResult
             });

             current = current.parent;
           }


            setBackpropSteps(steps);
            setShowBackprop(true);
            addLog(`Starting backpropagation with result: ${result.toFixed(2)}`, 'success');

            if (stepByStepMode) {
              setWaitingForNext(true);
            } else {
              // Auto-animate backprop
              animateBackprop(steps);
            }
          };

          const animateBackprop = (steps) => {
            let step = 0;
            const interval = setInterval(() => {
              step++;
              setBackpropStep(step);

              setForceRedraw(prev => prev + 1);

              if (step >= steps.length) {
                clearInterval(interval);
                setTimeout(() => {
                  setShowBackprop(false);
                  setCurrentPhase('idle');
                  setCurrentIteration(prev => prev + 1);
                  setWaitingForNext(false);
                }, 1500);
              }
            }, 800);
          };


    const nextSimulationStep = () => {
  if (currentPhase !== 'simulation' || !waitingForNext) return;
  const nextStep = simulationStep + 1;
  setSimulationStep(nextStep);

  if (nextStep >= simulationNodes.length) {
    setSimulationResult({ result: 0, winner: simulationWinner });
    addLog('Simulation complete - click Finish Simulation to continue', 'info');
    // Don't auto-advance - wait for user to click Finish Simulation
  }
};

          const finishSimulation = () => {
            if (currentPhase !== 'simulation' || !waitingForNext) return;
            setSimulationStep(simulationNodes.length);
            setSimulationResult({ result: 0, winner: simulationWinner });

            setTimeout(() => {
              const result = simulationWinner === selectedNode.rootPlayer ? 1.0 : (simulationWinner === null ? 0.5 : 0.0);
              startBackpropagation(result, selectedNode);
            }, 1000);
          };

          const nextBackpropStep = () => {
            if (currentPhase !== 'backprop' || !waitingForNext) return;
            const nextStep = backpropStep + 1;
            setBackpropStep(nextStep);

            // Apply backpropagation to THIS specific node
            if (nextStep <= backpropSteps.length) {
              const step = backpropSteps[nextStep - 1];
              if (step.node) {
                step.node.visits = step.newVisits;  // Always update visits
                if (!step.isRoot) {
                  step.node.wins = step.newWins;  // Only update wins for non-root
                }
              }
            }

            // Force canvas redraw by updating a dummy state
            setCurrentIteration(prev => prev);

            if (nextStep >= backpropSteps.length) {
              addLog('Backpropagation complete', 'success');
            }
          };


          const finishBackprop = () => {
          if (currentPhase !== 'backprop' || !waitingForNext) return;

          // Apply all remaining backprop steps
          for (let i = backpropStep; i < backpropSteps.length; i++) {
            const step = backpropSteps[i];
            if (step.node) {
              step.node.visits = step.newVisits;
              if (!step.isRoot) {
                step.node.wins = step.newWins;
              }
            }
          }

          setBackpropStep(backpropSteps.length);

          setTimeout(() => {
            setShowBackprop(false);
            setCurrentPhase('idle');
            setCurrentIteration(prev => prev + 1);
            setWaitingForNext(false);
          }, 1000);
        };


          const autoPlay = () => {
            if (isPlaying && currentIteration < iterations && mctsRoot) {
              stepMCTS();
            }
          };

          useEffect(() => {
            if (isPlaying) {
              animationRef.current = setTimeout(autoPlay, speed);
            }
            return () => clearTimeout(animationRef.current);
          }, [isPlaying, currentIteration, speed, mctsRoot]);

          const resetVisualization = () => {
            setMctsRoot(null);
            setCurrentIteration(0);
            setIsPlaying(false);
            setLogs([]);
            setSelectedNode(null);
            setHighlightedPath([]);
            setPhase('idle');
            setShowSimulation(false);
            setSimulationNodes([]);
            setSimulationStartBoard(null);
            setSimulationResult(null);
            setSimulationStep(0);
            setSimulationWinner(null);
            setBackpropPath([]);
            setWaitingForNext(false);
            setShowSelection(false);
            setSelectionPath([]);
            setSelectionStep(0);
            setShowBackprop(false);
            setBackpropSteps([]);
            setBackpropStep(0);
            setCurrentPhase('idle');
          };

          const makeMove = () => {
            if (!mctsRoot || currentIteration < iterations) return;

            const bestChild = mctsRoot.bestChild(0);
            const move = bestChild.action;
            let newState = gameState.makeMove(move);

            addLog(`Player ${gameState.currentPlayer} chose move ${move}`, 'success');

            // Check if game is over
            if (newState.isTerminal()) {
              const winner = newState.getWinner();
              addLog(winner ? `Player ${winner} wins!` : "It's a draw!", 'success');
              setGameState(newState);
              resetVisualization();
              setPhase('gameover');
              return;
            }

            // Player 2's turn
            if (newState.currentPlayer === 2) {
              if (player2Engine === 'mcts') {
                // Player 2 uses MCTS
                addLog('Player 2 thinking with MCTS...', 'info');
                setGameState(newState);
                resetVisualization();
                // Start MCTS for Player 2 automatically
                setTimeout(() => {
                  const root = new MCTSNode(newState);
                  setMctsRoot(root);
                  setCurrentIteration(0);
                  setPhase('running');
                  addLog('Starting MCTS for Player 2', 'success');
                }, 500);
              } else {
                // Player 2 uses random
                const availableMoves = newState.getAvailableMoves();
                const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                newState = newState.makeMove(randomMove);
                addLog(`Player 2 (Random) chose move ${randomMove}`, 'info');

                if (newState.isTerminal()) {
                  const winner = newState.getWinner();
                  addLog(winner ? `Player ${winner} wins!` : "It's a draw!", 'success');
                  setPhase('gameover');
                }

                setGameState(newState);
                resetVisualization();
              }
            } else {
              setGameState(newState);
              resetVisualization();
            }
          };

          // Tree Drawing
          useEffect(() => {
            if (!mctsRoot || !canvasRef.current) return;

            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);

            const drawTree = (node, x, y, level, spacing, parent = null) => {
              const nodeRadius = 30;
              const levelHeight = 130;

              if (parent) {
                const isInBackprop = backpropPath.includes(node.id);
                ctx.strokeStyle = isInBackprop ? '#10b981' : (highlightedPath.includes(node.id) ? '#f59e0b' : '#6b7280');
                ctx.lineWidth = isInBackprop ? 4 : (highlightedPath.includes(node.id) ? 3 : 1);
                ctx.beginPath();
                ctx.moveTo(parent.x, parent.y + nodeRadius);
                ctx.lineTo(x, y - nodeRadius);
                ctx.stroke();
              }

              const isHighlighted = highlightedPath.includes(node.id);
              const isSelected = selectedNode && selectedNode.id === node.id;
              const isInBackprop = backpropPath.includes(node.id);

              let nodeColor = '#6b7280';
              if (!node.isRoot) {
                nodeColor = node.state.currentPlayer === 1 ? '#3b82f6' : '#ef4444';
              }

              if (isInBackprop) {
                nodeColor = '#10b981';
              } else if (isSelected) {
                nodeColor = '#8b5cf6';
              } else if (isHighlighted) {
                nodeColor = '#f59e0b';
              }

              ctx.fillStyle = nodeColor;
              ctx.beginPath();
              ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
              ctx.fill();

              ctx.strokeStyle = '#1f2937';
              ctx.lineWidth = isInBackprop ? 3 : 2;
              ctx.stroke();

              // Check if this node is in the backprop path
              const isInBackpropPath = showBackprop && backpropSteps.some(step =>
                step.node && step.node.id === node.id
              );

              // Check if backprop has reached this node yet
              const isBackpropDone = showBackprop && backpropSteps.some((step, idx) =>
  idx <= backpropStep && step.node && step.node.id === node.id
);
              // Check if this node is in the selection path
              const isInSelectionPath = showSimulation && highlightedPath.includes(node.id);

              // Show stats if: node has visits AND (not in selection path during simulation)
              // AND (not in backprop path OR backprop is done)
              const showStats = node.visits > 0 && (!showSimulation || !isInSelectionPath) && (!showBackprop || !isInBackpropPath || isBackpropDone);

              ctx.fillStyle = 'white';
              ctx.textAlign = 'center';

              if (showStats) {
                if (node.isRoot) {
                  ctx.font = 'bold 15px monospace';
                  ctx.fillText(`N:${node.visits}`, x, y);
                } else {
                  ctx.font = 'bold 12px monospace';
                  ctx.fillText(`V:${node.visits}`, x, y - 12);
                  ctx.fillText(`W:${node.wins.toFixed(1)}`, x, y);
                  ctx.fillText(`${node.getWinRate().toFixed(0)}%`, x, y + 12);
                }
              } else {
                ctx.font = 'bold 13px monospace';
                ctx.fillText('...', x, y);
              }

              if (node.action !== null) {
                ctx.fillStyle = '#1f2937';
                ctx.font = 'bold 15px monospace';
                ctx.fillText(`[${node.action}]`, x, y - nodeRadius - 18);
              }

              ctx.font = '12px monospace';
              ctx.fillStyle = '#1f2937';
              const boardStr = `[${node.state.board.join(',')}]`;
              ctx.fillText(boardStr, x, y + nodeRadius + 14);

              if (!node.isRoot) {
                ctx.font = 'bold 13px monospace';
                ctx.fillStyle = node.state.currentPlayer === 1 ? '#3b82f6' : '#ef4444';
                ctx.fillText(`P${node.state.currentPlayer}`, x, y + nodeRadius + 28);
              }

              // Better spacing algorithm to prevent overlap
              const numChildren = node.children.length;
              if (numChildren > 0) {
                const depthFactor = Math.pow(0.55, level);
                const minSpacing = 120;
                // Ensure minimum total width for all children
                const minTotalWidth = minSpacing * numChildren;
                const childWidth = Math.max(minTotalWidth, spacing * depthFactor);
                const childSpacing = childWidth / numChildren;
                const startX = x - (childWidth / 2) + (childSpacing / 2);

                node.children.forEach((child, i) => {
                  const childX = startX + i * childSpacing;
                  const childY = y + levelHeight;
                  drawTree(child, childX, childY, level + 1, childWidth, { x, y });
                });
              }
            };

            drawTree(mctsRoot, 900, 200, 0, 1500);

            // Draw selection/expansion box
            if (showSelection && selectionPath.length > 0) {
              const boxWidth = 350;
              const boxHeight = Math.min(120 + selectionPath.length * 32, 500);
              const boxX = 50;
              const boxY = 60;

              ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
              ctx.strokeStyle = '#f59e0b';
              ctx.lineWidth = 3;
              ctx.beginPath();
              const radius = 10;
              ctx.moveTo(boxX + radius, boxY);
              ctx.lineTo(boxX + boxWidth - radius, boxY);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
              ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
              ctx.lineTo(boxX + radius, boxY + boxHeight);
              ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
              ctx.lineTo(boxX, boxY + radius);
              ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();

              ctx.fillStyle = '#f59e0b';
              ctx.font = 'bold 18px sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText('ðŸ” Selection & Expansion', boxX + 15, boxY + 28);

              ctx.font = '14px monospace';
              ctx.fillStyle = '#1f2937';
              selectionPath.forEach((step, i) => {
                if (i < selectionStep) {
                  const yPos = boxY + 60 + i * 32;
                  if (step.expanded) {
                    ctx.fillStyle = '#10b981';
                    ctx.fillText(`âœ¨ Expanded: [${step.action}]`, boxX + 15, yPos);
                  } else if (i === 0) {
                    ctx.fillStyle = '#6b7280';
                    ctx.fillText(`Root`, boxX + 15, yPos);
                  } else {
                    ctx.fillStyle = '#1f2937';
                    ctx.fillText(`Select [${step.action}] UCB=${step.ucb.toFixed(2)}`, boxX + 15, yPos);
                  }
                }
              });
            }

            // Draw backpropagation box
            if (showBackprop && backpropSteps.length > 0) {
              const boxWidth = 400;
              const boxHeight = Math.min(120 + backpropSteps.length * 38, 600);
              const boxX = 50;
              const boxY = 60;

              ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
              ctx.strokeStyle = '#10b981';
              ctx.lineWidth = 3;
              ctx.beginPath();
              const radius = 10;
              ctx.moveTo(boxX + radius, boxY);
              ctx.lineTo(boxX + boxWidth - radius, boxY);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
              ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
              ctx.lineTo(boxX + radius, boxY + boxHeight);
              ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
              ctx.lineTo(boxX, boxY + radius);
              ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();

              ctx.fillStyle = '#10b981';
              ctx.font = 'bold 18px sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText('â¬†ï¸ Backpropagation', boxX + 15, boxY + 28);

              ctx.font = '13px monospace';
              backpropSteps.forEach((step, i) => {
                if (i < backpropStep) {
                  const yPos = boxY + 60 + i * 38;
                  const nodeLabel = step.isRoot ? 'Root' : `[${step.action}]`;

                  ctx.fillStyle = '#1f2937';
                  ctx.fillText(nodeLabel, boxX + 15, yPos);

                  ctx.fillStyle = '#6b7280';
                  ctx.fillText(`V: ${step.oldVisits}â†’${step.newVisits}`, boxX + 15, yPos + 16);

                  if (!step.isRoot) {
                    const winChange = step.newWins - step.oldWins;
                    ctx.fillStyle = winChange > 0 ? '#10b981' : '#ef4444';
                    ctx.fillText(`W: ${step.oldWins.toFixed(1)}â†’${step.newWins.toFixed(1)} (+${winChange.toFixed(1)})`, boxX + 120, yPos + 16);
                  }
                }
              });
            }

            // Draw simulation box
            if (showSimulation && simulationNodes.length > 0) {
              const boxWidth = 250;
              const visibleMoves = Math.min(simulationStep, simulationNodes.length);
              const boxHeight = Math.min(140 + visibleMoves * 30, 600);
              const boxX = 50; // Back on the left
              const boxY = 60;

              ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
              ctx.strokeStyle = '#8b5cf6';
              ctx.lineWidth = 3;
              ctx.beginPath();
              const radius = 10;
              ctx.moveTo(boxX + radius, boxY);
              ctx.lineTo(boxX + boxWidth - radius, boxY);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + radius);
              ctx.lineTo(boxX + boxWidth, boxY + boxHeight - radius);
              ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - radius, boxY + boxHeight);
              ctx.lineTo(boxX + radius, boxY + boxHeight);
              ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - radius);
              ctx.lineTo(boxX, boxY + radius);
              ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();

              ctx.fillStyle = '#8b5cf6';
              ctx.font = 'bold 18px sans-serif';
              ctx.textAlign = 'left';
              const rolloutType = useHeuristic ? 'Heuristic' : 'Random';
              ctx.fillText(`ðŸŽ² Simulation (${rolloutType})`, boxX + 15, boxY + 28);

              ctx.font = 'bold 15px monospace';
              ctx.fillStyle = '#1f2937';
              ctx.fillText('Start:', boxX + 15, boxY + 56);

              if (simulationStartBoard) {
                ctx.font = '14px monospace';
                ctx.fillStyle = '#059669';
                const startBoardStr = `[${simulationStartBoard.map(v => v === 0 ? 'Â·' : `P${v}`).join(',')}]`;
                ctx.fillText(startBoardStr, boxX + 75, boxY + 56);
              }

              ctx.strokeStyle = '#e5e7eb';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(boxX + 15, boxY + 65);
              ctx.lineTo(boxX + boxWidth - 15, boxY + 65);
              ctx.stroke();

              let currentBoard = [...simulationStartBoard];

              simulationNodes.forEach((move, i) => {
                if (i < simulationStep) {
                  const yPos = boxY + 85 + i * 30;
                  const color = move.player === 1 ? '#3b82f6' : '#ef4444';

                  if (i === simulationStep - 1) {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.12)';
                    ctx.fillRect(boxX + 10, yPos - 18, boxWidth - 20, 26);
                  }

                  currentBoard[move.move] = move.player;

                  ctx.fillStyle = color;
                  ctx.font = 'bold 14px monospace';
                  ctx.fillText(`P${move.player}`, boxX + 15, yPos);

                  ctx.fillStyle = '#1f2937';
                  ctx.font = '14px monospace';
                  ctx.fillText(`â†’pos${move.move}:`, boxX + 45, yPos);

                  const boardStr = `[${currentBoard.map(v => v === 0 ? 'Â·' : `P${v}`).join(',')}]`;
                  ctx.fillStyle = '#059669';
                  ctx.font = 'bold 14px monospace';
                  ctx.fillText(boardStr, boxX + 115, yPos);
                }
              });

              if (simulationResult) {
                const resultYPos = boxY + boxHeight - 45;

                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(boxX + 15, resultYPos);
                ctx.lineTo(boxX + boxWidth - 15, resultYPos);
                ctx.stroke();

                ctx.fillStyle = '#10b981';
                ctx.font = 'bold 15px sans-serif';
                ctx.fillText('Result:', boxX + 15, resultYPos + 18);

                ctx.font = 'bold 14px monospace';
                const resultText = simulationResult.winner ? `P${simulationResult.winner} Wins!` : 'Draw';
                const resultColor = simulationResult.winner === 1 ? '#3b82f6' : simulationResult.winner === 2 ? '#ef4444' : '#6b7280';
                ctx.fillStyle = resultColor;
                ctx.fillText(resultText, boxX + 15, resultYPos + 36);
              } else {
                const progressYPos = boxY + boxHeight - 18;
                ctx.fillStyle = '#8b5cf6';
                ctx.font = 'bold 13px sans-serif';
                ctx.fillText(`Step ${simulationStep}/${simulationNodes.length}`, boxX + 15, progressYPos);
              }
            }
          }, [mctsRoot, highlightedPath, selectedNode, currentIteration, showSimulation, simulationNodes, simulationStep, simulationResult, simulationStartBoard, backpropPath, useHeuristic, selectionPath, showSelection, selectionStep, backpropSteps, showBackprop, backpropStep, forceRedraw]);

          const BoardDisplay = ({ board, small = false }) => {
            const size = small ? 'w-10 h-10 text-sm' : 'w-16 h-16 text-lg';
            return (
              <div className="flex gap-1">
                {board.map((cell, i) => (
                  <div
                    key={i}
                    className={`${size} flex items-center justify-center border-2 rounded-lg font-bold ${
                      cell === 0 ? 'bg-gray-100 border-gray-300' :
                      cell === 1 ? 'bg-blue-500 border-blue-600 text-white' :
                      'bg-red-500 border-red-600 text-white'
                    }`}
                  >
                    {cell === 0 ? 'Â·' : `P${cell}`}
                  </div>
                ))}
              </div>
            );
          };

          return (
            <div className="w-full min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-4">
              <div className="w-full flex flex-col gap-4">
                <div className="bg-white rounded-lg shadow-lg p-4">
                  <h1 className="text-3xl font-bold text-gray-800 mb-2">MCTS Algorithm Visualizer</h1>
                  <p className="text-gray-600">Watch Monte Carlo Tree Search find optimal moves in real-time</p>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-8 gap-4">
                  <div className="flex flex-col gap-3">
                    <div className="bg-white rounded-lg shadow-lg">
                      <h2 className="text-base font-bold mb-2 text-gray-800 px-1 pt-1">Game State</h2>
                      <div className="space-y-3 px-1 pb-1">
                        <BoardDisplay board={gameState.board} />
                        <div className="text-sm text-gray-600">
                          Current Player: <span className="font-bold">Player {gameState.currentPlayer}</span>
                        </div>
                        {gameState.isTerminal() && (
                          <div className="text-lg font-bold text-green-600">
                            {gameState.getWinner() ? `Player ${gameState.getWinner()} Wins!` : "Draw!"}
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="bg-white rounded-lg shadow-lg">
                      <h2 className="text-base font-bold mb-2 text-gray-800 px-1 pt-1">Controls</h2>
                      <div className="space-y-2 px-1 pb-1">
                        <div>
                          <label className="block text-xs font-medium mb-1">Iterations: {iterations}</label>
                          <input type="range" min="10" max="100" value={iterations} onChange={(e) => setIterations(Number(e.target.value))} className="w-full" disabled={phase === 'running'} />
                        </div>
                        <div>
                          <label className="block text-xs font-medium mb-1">Speed: {speed}ms</label>
                          <input type="range" min="100" max="2000" step="100" value={speed} onChange={(e) => setSpeed(Number(e.target.value))} className="w-full" disabled={stepByStepMode} />
                        </div>

                        <div className="flex items-center gap-2 py-1">
                          <input type="checkbox" id="stepMode" checked={stepByStepMode} onChange={(e) => setStepByStepMode(e.target.checked)} className="w-4 h-4" />
                          <label htmlFor="stepMode" className="text-xs font-medium">Step-by-Step Mode</label>
                        </div>

                        <div className="flex items-center gap-2 py-1">
                          <input type="checkbox" id="heuristicMode" checked={useHeuristic} onChange={(e) => setUseHeuristic(e.target.checked)} className="w-4 h-4" />
                          <label htmlFor="heuristicMode" className="text-xs font-medium">Heuristic Rollout</label>
                        </div>

              <div className="py-1">
              <label className="block text-xs font-medium mb-1">Player 2 Engine:</label>
              <select
            value={player2Engine}
            onChange={(e) => setPlayer2Engine(e.target.value)}
            className="w-full px-2 py-1 text-xs border border-gray-300 rounded"
            disabled={phase === 'running'}
              >
              <option value="random">Random</option>
              <option value="mcts">MCTS</option>
              </select>
              </div>

                        <div className="flex gap-2">
                          {!mctsRoot ? (
                            <button onClick={startMCTS} disabled={gameState.isTerminal()} className="flex-1 bg-green-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                              <Play /> Start
                            </button>
                          ) : (
                            <>
                              <button onClick={() => setIsPlaying(!isPlaying)} disabled={currentIteration >= iterations || stepByStepMode || waitingForNext} className="flex-1 bg-blue-600 text-white px-2 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-300 flex items-center justify-center gap-1">
                                {isPlaying ? <Pause /> : <Play />}
                              </button>
                              <button onClick={stepMCTS} disabled={(currentIteration >= iterations || isPlaying) && !waitingForNext} className="bg-blue-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-300">
                                <SkipForward />
                              </button>
                            </>
                          )}
                        </div>

                        {waitingForNext && stepByStepMode && (
                            <div className="space-y-2">
                            {currentPhase === 'selection' && (
  <>
    <button
      onClick={nextSelectionStep}
      disabled={selectionStep >= selectionPath.length}
      className="w-full bg-orange-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-orange-700 disabled:bg-gray-300"
    >
      Next Select ({selectionStep}/{selectionPath.length})
    </button>
    <button
      onClick={finishSelection}
      className="w-full bg-orange-500 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-orange-600"
    >
      Finish Selection
    </button>
  </>
)}
{currentPhase === 'simulation' && (
  <>
    <button
      onClick={nextSimulationStep}
      disabled={simulationStep >= simulationNodes.length}
      className="w-full bg-purple-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-purple-700 disabled:bg-gray-300"
    >
      Next Sim Step ({simulationStep}/{simulationNodes.length})
    </button>
    <button
      onClick={finishSimulation}
      className="w-full bg-purple-500 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-purple-600"
    >
      Finish Simulation
    </button>
  </>
)}
{currentPhase === 'backprop' && (
  <>
    <button
      onClick={nextBackpropStep}
      disabled={backpropStep >= backpropSteps.length}
      className="w-full bg-green-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-green-700 disabled:bg-gray-300"
    >
      Next Backprop ({backpropStep}/{backpropSteps.length})
    </button>
    <button
      onClick={finishBackprop}
      className="w-full bg-green-500 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-green-600"
    >
      Finish Backprop
    </button>
  </>
)}
                          </div>
                        )}

                        {mctsRoot && currentIteration >= iterations && (
                          <button onClick={makeMove} className="w-full bg-green-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-green-700">
                            Make Best Move
                          </button>
                        )}

                        <button onClick={resetVisualization} className="w-full bg-gray-600 text-white px-3 py-2 rounded-lg text-sm font-medium hover:bg-gray-700 flex items-center justify-center gap-2">
                          <RotateCcw /> Reset
                        </button>

                        <div className="text-xs text-gray-600 text-center">
                          Progress: {currentIteration} / {iterations}
                        </div>
                      </div>
                    </div>

                    {selectedNode && (
                      <div className="bg-white rounded-lg shadow-lg">
                        <h2 className="text-base font-bold mb-2 text-gray-800 px-1 pt-1">Selected Node</h2>
                        <div className="space-y-1 text-xs px-1 pb-1">
                          <div>Action: <span className="font-bold">{selectedNode.action ?? 'Root'}</span></div>
                          <div>Visits: <span className="font-bold">{selectedNode.visits}</span></div>
                          {!selectedNode.isRoot && (
                            <>
                              <div>Wins: <span className="font-bold">{selectedNode.wins.toFixed(1)}</span></div>
                              <div>Win Rate: <span className="font-bold">{selectedNode.getWinRate().toFixed(1)}%</span></div>
                            </>
                          )}
                          <div className="pt-2">
                            <div className="text-xs text-gray-600 mb-1">Board State:</div>
                            <BoardDisplay board={selectedNode.state.board} small />
                          </div>
                        </div>
                      </div>
                    )}
                  </div>

                  <div className="lg:col-span-7 bg-white rounded-lg shadow-lg p-4 flex flex-col" style={{minHeight: '700px'}}>
                    <h2 className="text-xl font-bold mb-3 text-gray-800">Search Tree</h2>
                    <div className="flex-1 border-2 border-gray-200 rounded-lg canvas-container">
                      <canvas ref={canvasRef} width={1800} height={900} />
                    </div>
                    <div className="mt-3 grid grid-cols-4 gap-2 text-xs">
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 bg-gray-500 rounded-full"></div>
                        <span>Root</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 bg-blue-500 rounded-full"></div>
                        <span>Player 1</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 bg-red-500 rounded-full"></div>
                        <span>Player 2</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <div className="w-4 h-4 bg-green-500 rounded-full"></div>
                        <span>Backprop</span>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="bg-white rounded-lg shadow-lg p-4">
                  <h2 className="text-lg font-bold mb-2 text-gray-800">Activity Log</h2>
                  <div className="h-32 overflow-y-auto text-xs font-mono space-y-1">
                    {logs.map((log) => (
                      <div key={log.time} className={log.type === 'success' ? 'text-green-600' : log.type === 'error' ? 'text-red-600' : 'text-gray-600'}>
                        {log.message}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<MCTSVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>
